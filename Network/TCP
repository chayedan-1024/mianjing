主要特点
  面向连接的运输层协议
  点对点
  全双工通信：允许通信双方的应用进程在任何时候都能发送数据，TCP 连接的两端都设有发送缓存和接受缓存，
  用来临时存放双向通信的数据。
  面向字节流
  
面向字节流
  虽然应用程序和 TCP 的交互式一次一个数据块(大小不等)，但 TCP 把应用程序交下来的数据仅仅看成是
  一连串的无结构的字节流。TCP 并不知道所传送的字节流的含义
  
TCP 的连接
  套接字 socket = (IP 地址：端口号)
  TCP 连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)}
  
可靠传输的工作原理
  理想的传输条件
    传输信道不产生差错
    不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据
    
  停止等待协议
    简单、信道利用率低
  出现差错
    超时重传 超时计时器
    发送完一个分组后，必须暂时保留已发送的分组的副本(在发生超时重传时使用)。
    只有在收到相应的确认后才能清除暂时保留的分组副本
    编号
    超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些
    
  确认丢失和确认迟到
    丢弃重复 （发送方）收下迟到确认什么也不做
    
  连续 ARQ 协议
    累积确认 对按序到达的最后一个分组发送确认
    容易实现，即使确认丢失也不必重传，但不能向发送方反映出接收方
    已经正确收到的所有分组的信息

首部格式
  源端口 2byte
  目的端口 2byte
  序号 4byte
  确认号 4byte
  数据偏移 4bit
  保留 6bit
  URG 1bit
  ACK 1bit
  PSH 1bit
  RST 1bit
  SYN 1bit
  FIN 1bit
  窗口 2byte
  校验和 2byte 检验和字段检验的范围包括首部和数据这两部分
  紧急指针 2byte 仅在URG=1时有意义
  选项 最长40byte
  
可靠传输的实现
  以字节为单位的滑动窗口
    发送窗口构造
    发送窗口变化
    要描述一个发送窗口的状态需要三个指针：P1，P2，P3
      小于 P1 的是已发送并已收到确认的部分，而大于 P3 的是不允许发送的部分
      P3 - P1 = A 的发送窗口
      P2 - P1 已发送但尚未收到确认的字节数
      P3 - P2 允许发送但当前尚未发送的字节数(又称为可用窗口或有效窗口)
  缓存和窗口
    发送缓存用来暂时存放：
      发送应用程序传送给对方 TCP 准备发送的数据
      TCP 已发送出但尚未收到确认的数据
    接收缓存用来暂时存放：  
      按序到达的、但尚未被接收应用程序读取的数据
      未按序到达的数据
  超时重传时间的选择
      新的 RTTs = (1 - α) x (旧的 RTTs) + α x (新的 RTT 样本)
      RTTs：加权平均往返时间
      RTO = RTTs + 4 x RTTD
      RTO：超时重传时间，RTTD：RTT的偏差的加权时间
      新的 RTTD = (1 - β) x (旧的 RTTD) + β x |RTTs - 新的 RTT 样本|

TCP流量控制（flow control)）
  让发送方的发送速率不要太快，要让接收方来得及接收
  
  利用滑动窗口机制可以很方便地在 TCP 连接上实现对发送方的流量控制
  
  避免死锁：TCP 为每一个连接设有一个持续计时器(persistence timer)。
  只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。
  若持续计时器设置的时间到期，就发送一个零窗口探测报文段(仅携带1字节的数据)，
  而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍是零，
  那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，
  那么死锁的僵局就可以打破了
  
  TCP 的传输效率
    发送机制
      TCP 维持一个变量，它等于最大报文段长度 MSS，只要缓存中存放的数据达到 MSS 字节时，
      就组装成一个 TCP 报文段发送出去
      由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送(push)操作
      发送方的一个计时器期限到了，这时把当前已有的缓存数据装入报文段
      (但长度不能超过 MSS)发送出去
      
    Nagle 算法
      若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，
      则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。
      当发送方收到对第一个数据字符的确认后，
      再把发送缓存中的所有数据组装成一个报文段发送出去，
      同时继续对随后到达的数据进行缓存。
      只有在收到对前一个报文段的确认后才继续发送下一个报文段。
      当数据达到较快而网络速率较慢时，用这样的方法可明显地减少所用的网络宽带。
      Nagle 算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，
      就立即发送一个报文段。这样可以有效提高网络的吞吐量
      
    糊涂窗口综合征
      TCP 接收方的缓存已满，仅剩一个字节，并还将保持这种状态持续一段时间。
      导致发送方只能发送一个字节。导致网络的效率很低
      让接收方等待一段时间，使得或者接受缓存已有足够空间容纳一个最长的报文段，或者等到接受缓存已有一半空闲的空间。
      
    TCP 的拥塞控制
      拥塞控制的一般原理
        若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞(congestion)
      拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。
      
      TCP 的拥塞控制方法
        TCP 进行拥塞控制的算法有四种，即慢开始(slow-start)、拥塞避免(congestion avoidance)、
        快重传(fast retransmit)和快恢复(fast recovery)
        
        慢开始
        由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值
        cwnd：发送方的拥塞窗口，开始发送方设置 cwnd = 1
        
        拥塞避免
        让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加1，
        而不是像慢开始阶段那样加倍增加。因此在拥塞避免阶段就有“加法增大” AI(Additive Increase)的特点。
        这表明在拥塞避免阶段，拥塞窗口 cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多
        当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时，就改成执行拥塞避免算法，拥塞窗口按线性规律增长
        
        快重传
        让发送方尽早知道发生了个别报文段的丢失。快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，
        而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认
        
        快恢复
        发送发知道当前只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值 
        ssthresh = cwnd / 2 = 8，同时设置拥塞窗口 cwnd = ssthresh = 8，并开始执行拥塞避免算法
        
        TCP 的运输连接管理
          最初客户/服务器的 TCP 进程都处于 CLOSED(关闭)状态。在本实例中，A 主动打开连接，而 B 被动打开连接
          B 的 TCP 服务器进程先创建传输控制块 TCB，并处于 LISTEN(收听) 状态，等待客户的连接请求
          A 的 TCP 客户进程创建传输控制模块 TCB。并向 B 发出连接请求报文段，首部中的同部位 SYN = 1，选择一个初始序号 seq = x。TCP 客户端进程进入 SYN-SENT(同步已发送) 状态。TCP 规定，SYN 报文段(即 SYN = 1 的报文段)不能携带数据，但要消耗一个序号
          B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。这时 TCP 服务器进程进入 SYN-RCVD(同步收到) 状态。这个报文段也不能携带数据，但同样要消耗掉一个序号
          TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置1，确认号 ack = y + 1，而自己的序号 seq = x + 1。TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED(已建立连接) 状态
          当 B 收到 A 的确认后，也进入 ESTABLISHED 状态
          
          异常情况：A 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。假定不采用报文握手，那么只要 B 发出确认，
          新的连接就建立了。采用三报文握手的办法，可以防止上述现象的发生
          
        TCP 的连接释放  
          A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置1，其序号 seq = u，它等于前面已传送过的数据的最后一个字节的序号加1。这时 A 进入 FIN-WAIT-1(终止等待1) 状态，等待 B 的确认。TCP 规定，FIN 报文段即使不携带数据，也消耗一个序号
          B 收到连接释放报文段后即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v，等于 B 前面已传送过的数据的最后一个字节的序号加1。B随即进入 CLOSE-WAIT(关闭等待) 状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于 半关闭(half-close) 状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间
          A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2) 状态，等待 B 发出的连接释放报文段
          若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。现假定 B 的序号为 w(在半关闭状态 B 可能又发送了一些数据)。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认)状态，等待 A 的确认
          A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 ACK 置1，确认号 ack = w + 1，而自己的序号是 seq = u + 1(根据 TCP 标准，前面发送过的 FIN 报文段要消耗一个序号)。然后进入到 TIME-WAIT(时间等待)状态。此时 TCP 连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后，A 才进入到 CLOSED 状态
          当 A 撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接
          
          TIME-WAIT 等待时间  
            为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时 重传这个 FIN + ACK 报文段，
            而 A 就能在 2MSL 时间内收到这个重传的 FIN + ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。
            如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段。这样，B 就无法安装正常步骤进入 CLOSED 状态
            
            保活计时器(keepalive timer)：服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。
